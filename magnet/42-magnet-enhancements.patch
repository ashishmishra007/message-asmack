--- ../4.0.6/org/jivesoftware/smack/XMPPConnection.java	2015-01-08 02:17:12.347005123 -0800
+++ org/jivesoftware/smack/XMPPConnection.java	2015-01-08 02:17:12.335005126 -0800
@@ -139,6 +139,17 @@
             new ConcurrentHashMap<PacketListener, ListenerWrapper>();
 
     /**
+     * List of PacketListeners that will be notified when a packet sent successfully.
+     */
+    protected final Map<PacketListener, ListenerWrapper> sentListeners =
+            new ConcurrentHashMap<PacketListener, ListenerWrapper>();
+    
+    /**
+     * List of PacketListeners that will be notified when packet send failure occurred.
+     */
+    protected final Map<PacketListener, ListenerWrapper> failedListeners =
+            new ConcurrentHashMap<PacketListener, ListenerWrapper>();
+    /**
      * List of PacketInterceptors that will be notified when a new packet is about to be
      * sent to the server. These interceptors may modify the packet before it is being
      * actually sent to the server.
@@ -923,6 +934,106 @@
     }
 
     /**
+     * Registers a sent packet listener with this connection. The listener will be
+     * notified of every packet that this connection sent. A packet filter determines
+     * which packets will be delivered to the listener. Note that the thread
+     * that writes packets will be used to invoke the listeners. Therefore, each
+     * packet listener should complete all operations quickly or use a different
+     * thread for processing.
+     * 
+     * @param packetListener the packet listener to notify of sent packets.
+     * @param packetFilter   the packet filter to use.
+     */
+    public void addPacketSentListener(PacketListener packetListener, PacketFilter packetFilter) {
+        if (packetListener == null) {
+            throw new NullPointerException("Packet listener is null.");
+        }
+        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);
+        sentListeners.put(packetListener, wrapper);
+    }
+
+    /**
+     * Removes a packet listener for sent packets from this connection.
+     * 
+     * @param packetListener the packet listener to remove.
+     */
+    public void removePacketSentListener(PacketListener packetListener) {
+        sentListeners.remove(packetListener);
+    }
+
+    /**
+     * Get a map of all packet listeners for sending packets of this connection.
+     * 
+     * @return a map of all packet listeners for sent packets.
+     */
+    protected Map<PacketListener, ListenerWrapper> getPacketSentListeners() {
+        return sentListeners;
+    }
+    
+    private void firePacketSentListeners(Packet packet) {
+      // Notify the listeners of the actually sent packet
+      for (ListenerWrapper listenerWrapper : sentListeners.values()) {
+          try {
+              listenerWrapper.notifyListener(packet);
+          }
+          catch (NotConnectedException e) {
+              LOGGER.log(Level.WARNING, "Got not connected exception, aborting");
+              break;
+          }
+      }
+    }
+    
+    /**
+     * Registers a send failure packet listener with this connection. The 
+     * listener will be notified of the packet that this connection send failed.
+     * A packet filter determines which packets will be delivered to the 
+     * listener. Note that the thread that writes packets will be used to invoke
+     * the listeners. Therefore, each packet listener should complete all 
+     * operations quickly or use a different thread for processing.
+     * 
+     * @param packetListener the packet listener to notify of send failure packets.
+     * @param packetFilter   the packet filter to use.
+     */
+    public void addPacketFailedListener(PacketListener packetListener, PacketFilter packetFilter) {
+        if (packetListener == null) {
+            throw new NullPointerException("Packet listener is null.");
+        }
+        ListenerWrapper wrapper = new ListenerWrapper(packetListener, packetFilter);
+        failedListeners.put(packetListener, wrapper);
+    }
+
+    /**
+     * Removes a packet listener for send failure packets from this connection.
+     * 
+     * @param packetListener the packet listener to remove.
+     */
+    public void removePacketFailedListener(PacketListener packetListener) {
+        failedListeners.remove(packetListener);
+    }
+
+    /**
+     * Get a map of all packet listeners for sending packets of this connection.
+     * 
+     * @return a map of all packet listeners for sent packets.
+     */
+    protected Map<PacketListener, ListenerWrapper> getPacketFailedListeners() {
+        return failedListeners;
+    }
+
+    private void firePacketFailedListeners(Packet packet, Exception cause) {
+      // Notify the listeners of the send failure packet
+      for (ListenerWrapper listenerWrapper : failedListeners.values()) {
+          try {
+              listenerWrapper.notifyListener(packet);
+          }
+          catch (NotConnectedException e) {
+              LOGGER.log(Level.WARNING, "Got not connected exception, aborting");
+              break;
+          }
+      }
+    }
+    
+    /**
      * Registers a packet interceptor with this connection. The interceptor will be
      * invoked every time a packet is about to be sent by this connection. Interceptors
      * may modify the packet to be sent. A packet filter determines which packets
@@ -1203,6 +1314,18 @@
         }
     }
 
+    // Magnet Extension
+    protected void callPacketSent(Packet packet) {
+      LOGGER.log(Level.FINE, "Packet "+packet.getPacketID()+" sent");
+      firePacketSentListeners(packet);
+    }
+
+    protected void callPacketFailed(Packet packet, Exception e) {
+      LOGGER.log(Level.WARNING, "Packet "+packet.getPacketID()+" failure", e);
+      firePacketFailedListeners(packet, e);
+    }
+    // Magnet Extension
+
     /**
      * A wrapper class to associate a packet filter with a listener.
      */
--- ../4.0.6/org/jivesoftware/smack/util/LazyStringBuilder.java	2015-01-08 02:17:12.387005125 -0800
+++ org/jivesoftware/smack/util/LazyStringBuilder.java	2015-01-08 02:17:12.379005125 -0800
@@ -16,6 +16,9 @@
  */
 package org.jivesoftware.smack.util;
 
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Writer;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -105,4 +108,55 @@
         }
         return cache;
     }
+    
+    // Magnet extension.
+    public void write(Writer writer) throws IOException {
+      if (cache != null) {
+        // Use cached xml if available
+        writer.write(toString());
+        return;
+      }
+      // Recursively to write them out in chunks.
+      StringBuilder sb = new StringBuilder(8192);
+      for (CharSequence csq : list) {
+        if (csq instanceof XmlStringBuilder) {
+          // Flush any buffered fragments first.
+          if (sb.length() > 0) {
+            writer.write(sb.toString());
+            sb.setLength(0);
+          }
+          // Recursively write the fragments.
+          ((XmlStringBuilder) csq).write(writer);
+        } else {
+          int csqLen = csq.length();
+          if ((sb.length() + csqLen) <= 8192) {
+            // Buffer a small fragment.
+            sb.append(csq);
+          } else {
+            // Flush the buffered fragments.
+            if (sb.length() > 0) {
+              writer.write(sb.toString());
+              sb.setLength(0);
+            }
+            int start = 0;
+            // Write a large fragment directly in 8K chunks.
+            while (csqLen > 0) {
+              int len = Math.min(csqLen, 8192);
+              writer.write(csq.subSequence(start, start+len).toString());
+              start += len;
+              csqLen -= len;
+            }
+          }
+        }
+        // Is it a file based CharSequence?
+        if (csq instanceof Closeable) {
+          ((Closeable) csq).close();
+        }
+      }
+      // Flush any remaining buffered fragments.
+      if (sb.length() > 0) {
+        writer.write(sb.toString());
+        sb.setLength(0);
+      }
+    }
 }
--- ../4.0.6/org/jivesoftware/smack/util/XmlStringBuilder.java	2015-01-08 02:17:12.423005126 -0800
+++ org/jivesoftware/smack/util/XmlStringBuilder.java	2015-01-08 02:17:12.415005127 -0800
@@ -16,6 +16,9 @@
  */
 package org.jivesoftware.smack.util;
 
+import java.io.IOException;
+import java.io.Writer;
+
 import org.jivesoftware.smack.packet.PacketExtension;
 
 public class XmlStringBuilder implements Appendable, CharSequence {
@@ -240,4 +243,9 @@
     public int hashCode() {
         return toString().hashCode();
     }
+    
+    // Magnet extension.
+    public void write(Writer writer) throws IOException {
+      sb.write(writer);
+    }
 }
--- ../4.0.6/org/jivesoftware/smack/tcp/PacketWriter.java	2015-01-08 02:17:12.463005127 -0800
+++ org/jivesoftware/smack/tcp/PacketWriter.java	2015-01-08 02:17:12.455005127 -0800
@@ -20,6 +20,7 @@
 import org.jivesoftware.smack.SmackException.NotConnectedException;
 import org.jivesoftware.smack.packet.Packet;
 import org.jivesoftware.smack.util.ArrayBlockingQueueWithShutdown;
+import org.jivesoftware.smack.util.XmlStringBuilder;
 
 import java.io.IOException;
 import java.io.Writer;
@@ -153,18 +154,25 @@
     }
 
     private void writePackets(Thread thisThread) {
+        Packet packet = null;
         try {
             // Open the stream.
             openStream();
             // Write out packets from the queue.
             while (!done && (writerThread == thisThread)) {
-                Packet packet = nextPacket();
+                packet = nextPacket();
                 if (packet != null) {
-                    writer.write(packet.toXML().toString());
-
-                    if (queue.isEmpty()) {
-                        writer.flush();
-                    }
+                  CharSequence packetXml = packet.toXML();
+                  if (packetXml instanceof XmlStringBuilder) {
+                    ((XmlStringBuilder) packetXml).write(writer);
+                  } else {
+                    writer.write(packetXml.toString());
+                  }
+                  if (queue.isEmpty()) {
+                      writer.flush();
+                  }
+                  connection.notifyPacketSent(packet);
+                  packet = null;
                 }
             }
             // Flush out the rest of the queue. If the queue is extremely large, it's possible
@@ -172,8 +180,15 @@
             // by the shutdown process.
             try {
                 while (!queue.isEmpty()) {
-                    Packet packet = queue.remove();
-                    writer.write(packet.toXML().toString());
+                    packet = queue.remove();
+                    CharSequence packetXml = packet.toXML();
+                    if (packetXml instanceof XmlStringBuilder) {
+                      ((XmlStringBuilder) packetXml).write(writer);
+                    } else {
+                      writer.write(packetXml.toString());
+                    }
+                    connection.notifyPacketSent(packet);
+                    packet = null;
                 }
                 writer.flush();
             }
@@ -212,6 +227,13 @@
             // or if the it was caused because the socket got closed
             if (!(done || connection.isSocketClosed())) {
                 shutdown();
+                if (packet != null) {
+                  connection.notifyPacketFailed(packet, ioe);
+                }
+                while (!queue.isEmpty()) {
+                  packet = queue.remove();
+                  connection.notifyPacketFailed(packet, ioe);
+                }
                 connection.notifyConnectionError(ioe);
             }
         }
--- ../4.0.6/org/jivesoftware/smack/tcp/XMPPTCPConnection.java	2015-01-08 02:17:12.503005128 -0800
+++ org/jivesoftware/smack/tcp/XMPPTCPConnection.java	2015-01-08 02:17:12.495005129 -0800
@@ -847,6 +847,16 @@
         callConnectionClosedOnErrorListener(e);
     }
 
+    // Magnet Extension
+    synchronized void notifyPacketSent(Packet packet) {
+        callPacketSent(packet);
+    }
+
+    synchronized void notifyPacketFailed(Packet packet, Exception cause) {
+        callPacketFailed(packet, cause);
+    }
+    // Magnet Extension
+
     @Override
     protected void processPacket(Packet packet) {
         super.processPacket(packet);
